Title:  Writeup for Project 4, Spring 2010

 Date:  04/28/2010

 Group Num 03 :        Name            USC Email        Student ID

                       Alex Lee        alexl            6922218502
                       Kris Tai        ktai             6353657107
		       Tim Zimmer      tzimmer 		4814912664

*********************************************
**Project 4 Test Documentation see part V.**
*********************************************

I. Requirements:
	
	Part A:
	create 7 different types of threads: Passengers, Airport Liaisons, Airline Check-In Staff,
  		Cargo Handlers, Screening Officers, Security Inspectors, and an Airport Manager.
 		 	Each thread type has different responsibilities
 		I. Passengers
: 			+ There must be at least 20 passengers
 			+ two types: Executive and Economy
 			+ Each carries 2-3 pieces baggage and a ticket
 			+ Passengers are created
 			+ Passenger waits in shortest line of Airline Liaisons
             		+ When Passenger is called, gives AL ticket
 			+ Passenger either waits in executive or shortes economy line of the Check-In Staff of the airline
  				specified by the AL depending on their type
 			+ When called, Passenger gives ticket and baggage to CIS
 			+ Passenger waits in shortest Screening Officer line
 			+ If necessary, Passenger will undergo questioning before continuing
 			+ If Security Inspector gives ok, Passenger gives boarding pass
 			+ Passenger proceeds to boarding area and waits for the boarding announcement
 		II. Airport Liaison:
 			+ There can be 5 to 7 Airport Liaisons
 			+ AL calls one passenger at a time
 			+ When AL recieves ticket from Passenger, will direct Passenger to correct Airline
 			+ AL records the amount of baggage and which Airline it goes to
  		III. Airline Check-In Staff:
 			+ There must be 3 to 5 Check-in Staff per Airline
 			+ one line per CIS plus one executive passenger line per airline
			+ Each CIS calls one Passenger at a time (executive line has priority over their own line)
 			+ CIS takes asks for Passenger ticket and baggage
 			+ CIS gives Passenger boarding pass with seat number assignment (no duplicates per airline)
 			+ CIS tags Passenger baggage with airline code and weight
 			+ CIS puts baggage on conveyor belt (shared by all airlines)
 			+ CIS dismisses Passenger (?)
 			+ CIS records number of passengers to check in and their baggage count
 			+ CIS can go on break if economy AND their line are both empty
 			+ When all Passengers check in, close check-in kiosk (all go on break?)
           	IV. Cargo Handler
 			+ There can be between 6 to 10 Cargo Handlers
 			+ CH will pick up baggage from conveyor, read airline code, and drop off at appropriate aircraft.
	                + CH record number of baggage loaded into each aircraft
 			+ CH can go on break when conveyor is empty
            		+ CH all on break or at work at the same time (all or none)
 		V. Screening Officer:
 			+ SO handles one Passenger at a time from their line
 			+ SO generates Pass/Fail report on Passenger (percentage chance of fail)
 			+ SO sends Passenger and report to first available Security Inspector
 		VI. Security Inspector:
 			+ There must be the same number of SI's as SO's
 			+ SI handles one Passenger at a time
 			+ SI creates their own PASS/FAIL report
 			+ If either SO or SI security reports are FAIL, SI sends Passenger to be questioned
 			+ SI must handle their own Passenger returning from questioning before another Passenger from any SO
 			+ SI verifies that each cleared Passenger holds a valid boarding pass
 			+ SI records number of Passengers cleared per airline
  		VII. Airport Manager:
 			+ There is only one airport manager
 			+ AM checks reports (passenger or baggage) at random intervals to ensure no race conditions
             		+ AM signals back to work if there is baggage and CH's are on break
             		+ When all Passengers and baggage have reached the airline, AM makes boarding announcement
 			+ AM never goes on break
      There must be at least 3 airlines

	Part B:
	Implement the Token Ring algorithm for handling access to critical regions.

		+ Create a network thread for every thread created (e.g. Passenger thread, Airport Liaison thread, etc.)
		+ Network thread handles syscalls from User thread (passenger, etc) and makes requests to server
		+ Separate Passenger, Airport Liaison, etc. functions into separate entities or user programs
		+ Each client will run a set(number) of one type of user program
		+ Monitor Variables held on the server will contain the old important global variables
		+ Each user program will 'register' itself with the server
		+ when all user programs are registered, the server will send lists containing all members of the network
		+ when a lock is created by the server, it will 'pass' the lock (message) off to a member of the network
		+ the lock (message) will be passed around the 'circle' of members and not concern the server any longer
		+ multiple create requests will be ignored by the server (i.e. keeps track of locks created)
		+ 

II. Assumptions: 

	Part A:	
	+ The 2-3 baggage items handled by the check-in staff per passenger does not include their carry-on baggage
	+ One aircraft/flight per airline
	+ Any number of Screening Officers/Security Inspectors allowable as long as their relationship remains 1 to 1
	+ Screening Officers have lines exactly like Airport Liaisons
	+ SO's hold their current Passenger until sending them to available SI
	+ Passengers, Airport Liaisons, Screening Officers, and Security Inspectors never go on break
	+ All Passenger baggage checked takes up one "slot" on the conveyor (is treated as a single item)
	+ SI have lines... the only passengers to get in those lines are those returning from questioning
	+ Passengers place their bags down all at the same time.
	+ Check-in staff and cargo handlers pick up a customer's bags all at once. 
         
	Part B:
	+ Airport interactions may be simplified in light of the growing complexities caused by distributing the system
	+ Using project 2 memory paradigm for added simplicity
	
	
III. Design:
	
	A. A server runs continuously waiting for client requests sent over the network.
	B. Clients send lock, CV, and MV requests to the server through their network threads.
	C. All locks and CVs are passed around or held onto by the network threads when required by their individual user threads.
	D. Clients wait until a token(message) is received from the 'circle' before continuing.
	E. 
   		
		
IV. Implementation:

            + Files Modified:
			Modify /trunk/code/network/Project3Server.cc 
			Modify /trunk/code/threads/main.cc 
			Modify /trunk/code/machine/machine.h
  			Modify /trunk/code/machine/translate.cc 
  			Modify /trunk/code/test/exectest.c
  			Modify /trunk/code/test/halt.c
  			Modify /trunk/code/threads/system.cc
  			Modify /trunk/code/threads/system.h
  			Modify /trunk/code/threads/thread.cc
  			Modify /trunk/code/threads/thread.h 
  			Modify /trunk/code/userprog/addrspace.cc
 			Modify /trunk/code/userprog/addrspace.h 
  			Modify /trunk/code/userprog/exception.cc 
  			Modify /trunk/code/userprog/nachos
  			Modify /trunk/code/userprog/progtest.cc
  			Modify /trunk/code/userprog/syscall.h 
  			Modify /trunk/code/vm/Makefile 
  			Modify /trunk/code/vm/nachos 
			Modify /trunk/code/test/start.s 
			Modify /trunk/code/network/ServerLock.cc
			Modify /trunk/code/network/post.h 
			Modify /trunk/code/test/lockTest1.c
  			Modify /trunk/code/test/lockTest2.c 
			
			
			            
	    + Files added
			PassengerClient.c
			AirportLiaisonClient.c
			AirportManagerClient.c
			CargoHandlerClient.c
			SecurityOfficerClient.c
			SecurityInspectorClient.c
			CheckInStaffClient.c

			Passenger.c
			AirportLiaison.c
			AirportManager.c
			CargoHandler.c
			SecurityOfficer.c
			SecurityInspector.c
			CheckInStaff.c
			
			
            + Data Structures added, and the file they were added to.
		the following to system.cc / h
			ipt
			fifoCounter
			fifo
			tlbCounter
		the following to Project3Server.cc
			serverLockTable
			serverCondTable
			
			
            + Data Structures modified, and the file they were added to.
			N/A
			
            + Functions added and in which file.
			N/A	

            + Functions modified and in which file.
		the following to exception.cc
						
			
			
V. Testing:  (For each test case, you must show)

            + How to test
			
			-in the code/vm/ directory, type the following to execute tests

				"run" - a shell script that calls exectest which tests 2 instances of the user program matmult	

			-in the code/network/ directory, do the following (in order) to execute a test.
				
				In one terminal: nachos -m 0 -server  --> this starts the server on machine 0.
				In another terminal: nachos -m 1 -x ../test/lockTest1 --> this tests locks and CVs.
				In another terminal: nachos -m 2 -x ../test/lockTest2 --> this completes the above test.
				

            + Test Output

			ExecTest:
				Aside from the printing of the default virtual address information, it should print out the final
				value of 7220. 
			*Important note: Exectest runs two instances of matmult (each 50+ pages > Memory), however only the final print
			statement for the second matmult will print out. This is because the first one prints out earlier, but it is
			impossible to see given the fact that the virtual addresses are constantly being printed out (the output will
			get lost amongst the print of VAs). The one way we know that is running is by looking at the amount of ticks.
			Each matmult runs about 50,000+ ticks, so a combined number of ticks > 100,000 means that both matmults have run,
			and that they have run to completion.

			lockTest1:
				This test will create two locks (lock0 and lock1) and one CV (cv0).
				It will then acquire lock0 and lock1.
				Then, it will send a Wait request with cv0 and lock0.  At this point, the program should be waiting.
				After Waiting, this test will release lock0 and lock1.

			lockTest2:
				This test will acquire lock0, which should be released when lockTest1 sent the Wait request.
				This test will then send a Signal request with cv0 and lock0.  
				Then it will release lock0.  This should wake up lockTest1.
				Then it will acquire lock1.  Lock1 will be available once lockTest1 wakes up and releases it.
				Then it will release lock1.


VI. Discussion:

            + Experiment expectation.  (What you hope will happen.)
			
			Exectest:
			The test should output 7220, which is the final result after the extensive multiplication / addition of the 
			two matrices. As mentioned before, however, there will only be one output, since the other userprogram will output
			its value before, when the system is still outputing virtual addresses. It will be impossible to notice this since 
			the console prints out the value at such rapidity.

			lockTest1/2:
			This set of tests should show that lock/CV requests are passed between the clients and the server.  It should also show that locks and CVs can be shared between multiple clients.


            + Experiment result.  (What actually happens.)
		
			Exectest:
			Correct output.
			
			lockTest1/2:
			Correct output.


            + Explanation

                    	The page fault exception is handled correctly, through the use of a swap file, tlb, and ipt. 

			
VII. Miscellaneous:

	+Note: faulty airport from early on came back to bite us when we needed to change it for this project.
		how much should we be marked off for a mistake we have already been punished for?

	

	
